# yaml-language-server: $schema=https://schemastore.org/yamllint.json
# Example format and required fields
  # - name: 
  #   description: 
  #   action: 
  #   verification: 
  #   exit_code: 
---
title: Linux Fundamentals
section: Working with the Command Line
tasks:

  - name: Knowing your terminal
    description: |
      The shell prompt is the terminal window’s title bar that, 
      by default, will have the following format:

      [ username@system_hostname  working_directory]$
    action: NEXT
    verification: SKIP_CHECK
    exit_code: 0

  - name: Administrator vs Regular User
    description: |
      The shell prompt ends with the symbol:
        - $ when running as a regular user
        - # when running as an administrator
    action: NEXT
    verification: SKIP_CHECK
    exit_code: 0

  - name: Running commands
    description: |
      The shell always expects a command FIRST
      or will generate an error because the order
      given won't be recognized by the shell. 
    action: "run some gibberish command. e.g. asdagdghjn"
    verification: SKIP_CHECK
    exit_code: 0

  - name: Running commands correctly
    description: |
      Linux is case sensitive
      What you type in the terminal has to be exact!
    action: |
      Run the `whoami` command, it will print your username
      Run the `Who am I` command, it will return an error 
    verification: SKIP_CHECK
    exit_code: 0

  - name: Running multiple commands
    description: |
      If you want to type more than one command on a line, 
      you can use the semicolon (;) as a command separator.
    action: Run `whoami; date`
    verification: SKIP_CHECK
    exit_code: 0

  - name: Running commands with options
    description: |
      Commands in Linux follow a standard syntax, often referred to as:

      command [options] [arguments]

      - `command`:  The program or instruction you are asking
                    the shell to execute (e.g., `ls`, `pwd`, `touch`).
      - `options`:  Used to modify the behavior of the command. 
                    They usually begin with a single hyphen for short options (e.g., `-l`)
                    or two hyphens for long options (e.g., `--long-listing`).
      - `arguments`:  The items or values the command acts upon.
                      This is often a file, a directory path, a user name, or a string of text.
    action: |
      run the `ls` command to list your files
      run the `ls -l` command to list them with more details, known as "long listing"
    verification: SKIP_CHECK
    exit_code: 0

  - name: Running commands with arguments
    description: |
      The `ls` command can also take arguments to specify what to list
      this can be single files or directories, multiple files or directories,
      or regular expressions
    action: |
      Run `ls -l ~/.bashrc` to list the (.bashrc) file in your home directory (~).
      Run `ls -l /home` to list the contents of the /home directory.
      Run `ls -l ~/.bashrc ~/.bash_history` to list multiple files.
      Run `ls -l /home /mnt` to list multiple directories.
      Run `ls -l /etc/*.conf` to list all .conf files in the /etc directory.
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using the date command
    description: |
      The `date` command print or set the system date and time

      Usage: date [OPTION]... [+FORMAT]

      To see all the format options use the `date --help` command
    action: |
      Print the date in the default format with the following command:
        $ date

      Print the date in short format
        $ date +%D

      Print only the year
        $ date +%Y

      Print only the month
        $ date +%B

      Print only the day of the week
        $ date +%A

      Convert seconds since the Epoch (1970-01-01 UTC) to a date
        $ date --date='@2147483647'
    verification: SKIP_CHECK
    exit_code: 0

  - name: Understanding the usage format of commands
    description: |
      All the commands come with short and long help.
      To see the short help, add the `--help` option to the command.

        e.g. `ls --help`
        e.g. `find --help`

      The first line presents the `Usage` format of the command.

        e.g. `Usage: ls [OPTION]... [FILE]...`
        e.g. `Usage: find [-H] [-L] [-P] [-Olevel] [-D debugopts] [path...] [expression]`

      The way we interpret this is:

       - <Empty> Argument is required
       - [] Optional argument
       - | Mutually exclusive arguments
       - … Many arguments are allowed

      So the usage of the `ls` command can be read as:

        "The ls command supports multiple optional options and arguments."
    action: |
      Run the `ls --help | head -1` command to print only the first line of the help
      Run the `find --help | head -1`
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using the df command
    description: |
      The `df` command prints information about the file system space usage.
      Usage: df [OPTION]... [PATH]...

      To see all the format options use the `df --help` command
    action: |
      Run `df` to see the default output
      Run `df /home` to see the space usage only of the /home directory
      run `df -h /home` to see the space usage in human readable format
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using the free command
    description: |
      The `free` command displays the amount of memory available on the system.
      Usage: free [OPTION]...

      To see all the format options use the `free --help` command
    action: |
      Run `free` to see the default output
      Run `free -h` to see the space usage in human readable format
      Run `free -m` to see the space usage in megabytes
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using the pwd command
    description: |
      The `pwd` command prints the name of the current working directory.
      Usage: pwd
    action: |
      Run `pwd` to see the default output
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using the uptime command
    description: |
      The `uptime` command prints the system uptime.
      Usage: uptime [OPTION]...

      To see all the format options use the `uptime --help` command
    action: |
      Run `uptime` to see the default output
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using the w command
    description: |
      The `w` command show who is logged on to the system.
      Usage: w [OPTION]...

      To see all the format options use the `w --help` command
    action: |
      Run `w` to see the default output
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using the last command
    description: | 
      The `last` command show a listing of last logged users
      Usage: last [OPTION]...

      To see all the format options use the `last --help` command
    action: |
      Run `last` to see the default output
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using the hostname command
    description: |
      The `hostname` command show or set the system hostname.
      Usage: hostname [OPTION]... [NAME]

      To see all the format options use the `hostname --help`
    action: |
      Run `hostname` to see the default output
      Run `hostname -s` to see the short hostname
      Run `hostname -f` to see the full hostname
    verification: SKIP_CHECK
    exit_code: 0

  - name: Exploring other commands
    description: |
      Here is a list of simple but useful commands

        - cal     display a calendar
        - echo    prints a given string
        - clear   clear the terminal screen (Ctrl+l)

    action: Explore their usage and run them all
    verification: SKIP_CHECK
    exit_code: 0

  - name: Shell hacks (TAB completion)
    description: |
      One of the most useful tools of the shell is TAB completion.

      TAB completion allows a user to quickly complete commands, file names or paths.
      By providing Linux with just enough information and then using TAB keystrokes. 
      
      If the information given is not unique, pressing TAB twice 
      displays all possible options so we can provide more clues.
    action: |
      Let's use TAB completion to long-list the `.bashrc` file in your home directory.

      First, navigate to the root directory: `cd /`

      Then, use TAB completion to build the path:
      1. Type `ls -l h` and press `TAB`. It should complete to `/home/`.
      2. Type the first character of your username and press `TAB`.
      3. Type the dot `.` and press `TAB` twice. Linux will show all dot-files in your home directory.
      4. Press `b` then `TAB` to complete the `.bashrc` path.
      5. Press `Enter` to execute the command.
    verification: SKIP_CHECK
    exit_code: 0`

  - name: Shell hacks (TAB completion cont.)
    description: |
      TAB completion also works with command, options and arguments
    action: |
      Type `useradd --` and hit TAB twice
      Linux will present all the `--` long options of the command
    verification: SKIP_CHECK
    exit_code: 0

  - name: Shell hacks (multi-line commands)
    description: |
      Sometimes commands, arguments and options will generate very long lines of text 
      that can be hard to manage or understand, in those cases breaking them into 
      multiple lines is very helpful.

      We can continue a command by adding a `\` backslash at the end of each line.
    action: |
      Let's use the `head -3` command to print first 3 lines of the following files:

          - /etc/passwd
          - /etc/group
          - /etc/hosts
          - /etc/profile
          - /etc/motd

      Run the command:
        $ head -3 /etc/passwd \
              /etc/group \
              /etc/hosts \
              /etc/profile \
              /etc/motd
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using shell history
    description: |
      The shell stores every single command executed in a file called 
      `~/.bash_history` that we can print using the `history` command.
    action: |
      Run `history` command
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using shell history (Cont.)
    description: |
      We can run a command from the history using the exclamation mark `!`
      followed by the command number
    action: |
      Select a command from your history, for instance `27` and run it.

        $ !27
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using shell history (Cont.)
    description: |
      You can also use your keyboard's UP and DOWN keys to navigate the history
    action: NEXT
    verification: SKIP_CHECK
    exit_code: 0

  - name: Keyboard shortcuts (movement)
    description: |
      The following are very useful keyboard shortcuts to move in the line

        - ctrl+a  move to the beginning of the line
        - ctrl+e  move to the end of the line
        - ctrl+left move one word to the left
        - ctrl+right move one word to the right
    action: NEXT
    verification: SKIP_CHECK
    exit_code: 0

  - name: Keyboard shortcuts (deletion)
    description: |
      The following are very useful keyboard shortcuts to delete in the line

        - ctrl+u  delete from the cursor to the beginning of the line
        - ctrl+k  delete from the cursor to the end of the line
        - ctrl+w  delete the word
    action: NEXT
    verification: SKIP_CHECK
    exit_code: 0

  - name: Keyboard shortcuts
    description: |
      The following are very useful keyboard shortcuts

        - ctrl+l  clear the screen
        - ctrl+d  exit the shell
        - ctrl+c  cancel a command
        - ctrl+z  kill a command
    action: NEXT
    verification: SKIP_CHECK
    exit_code: 0

  - name: Re-using arguments
    description: |
      The shell allows us recall the last argument from the previous command
      using the keyboard shortcut `alt + .` (dot). This avoids typing
      the same argument multiple times and is a great way to work faster.
    action: |
      Let's say we want to long-list a file and then check its size.

      Run the command:
        $ ls -l /etc/passwd
        
      Now, instead of typing the full `du -h /etc/passwd` use the shortcut:

        `du -h` then press `alt + .` (dot). The shell will insert the path.
    verification: SKIP_CHECK
    exit_code: 0

  - name: Using the tail and head commands
    description: |
      The `head` command prints the first ten lines of a file.
      The `tail` command prints the last ten lines of a file.

      In both commands you can specify the number of lines to print.
    action: |
      Run `head /etc/passwd`
      Run `tail /etc/passwd`
      Run `head -5 /etc/passwd`
      Run `tail -5 /etc/passwd`
      Run `head /etc/passwd | tail -2`
    verification: SKIP_CHECK
    exit_code: 0

  - name: Double bang (!!) command repetitions
    description: |
      Sometimes we execute a command and forget to add an argument or option.
      Instead of retyping the whole command, we can use the `!!` shortcut
      to repeat the previously executed command. This is especially useful
      when you need to add `sudo` or modify a command slightly.
    action: |
      Let's use the double bang shortcut with some examples.

      1. First, print the first ten lines of a file:
         `head /etc/passwd`

      2. Now, repeat the command but only print the first three lines:
         `!! -n 3`

      3. Finally, use the shortcut to run the previous command with `sudo`:
         `sudo !!`
    verification: SKIP_CHECK
    exit_code: 0

  - name: String substitution (^^)
    description: |
      You can quickly replace strings on the previous command using the `^^` shortcut.

      The format is:

        ^old_string^new_string
      
      This is a quick way to correct a typo in the last command you ran.
    action: |
      Let's run a command with a deliberate typo
        `ls -l /ect/passwd`

      You'll get a "No such file or directory" error.

      Now, run the command again and fix the typo using the shortcut:
        `^ect^etc`
    verification: SKIP_CHECK
    exit_code: 0
...